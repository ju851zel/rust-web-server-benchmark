1. JÖRG - Projekt Vorstellen, Idee, warum,
Todo
2. JULIAN - Perfomanter Server
Wir haben uns also dazu entschieden einen performanten Server in Rust zu implementieren. Der Server besitzt einen variablen Threadpool, wessen Größe vom User festgelegt wird. Dabei nimmt ein thread neue requests an und teilt diese auf einen Worker des Pools zu. So werden nacheinander Request abgearbeitet. Bei dem Grundgerüst haben wir uns an dem im Rust Buch vorgestellten tcp server orientiert. Um diesen haben wir dann ein HTTP request und Response Model gebaut, um so HTTP Nachrichten zu verarbeiten und Antworten zu schicken.
3. JÖRG - Penetrator bauen um Massstab zu haben, wie 
Todo
4. JULIAN - Andere Server, single threaded
Nachdem wir jetzt einen Multi Threaded Webserver haben und einen Penetrator um diesen zu testen, brauchen wir noch eine Alternative um einen Vergleich darstellen zu können. Also haben wir einen weiteren Webserver gebaut, welcher jedoch einen thread pro request aufmacht. Dieser ist zwar einfacher, geht bei zuvielen Requests jedoch in die Knie. Doch dazu später mehr. todo
5. JULIAN - Andere Server, non blocking
Als weiteren Vergleich haben wir noch einen Single Threaded Web Server implementiert. Natürlich nicht mit nur einem Thread der alle requests blockierend ab arbeitet, sondern nicht blockierend. Dabei haben wir uns überlegt, dass wir einen Server haben, welcher request an nimmt und diese anschließend in einer Warteschlange speichert bis der socket im request Daten zurück liefert. Währenddessen kann der Server anderen requests nachgehen. Die Abarbeitung geschieht auch nicht blockierend wenn also keine Daten verfügbar sind packt er den request wieder in die Warteschlange. Wenn alle Daten gelesen wurden vergleicht der Server ebenso den im HTTP Header angefragten Pfad mit dem im Speicher liegenden Directory und kann so die gewünschten Dateien zurück liefern. Dies macht er erneut non blocking.
Das besondere daran war, dass wir nicht auf die Funktionalität von Rust vertrauen konnten, da wir Um die Daten nicht blockieren abzuarbeiten diese eine Kernelqueue speichern müssen. Dafür mussten wir Syscalls aufrufen. Das wiederum geht nur mit unsafe rust.
6. JULIAN - Rust allgemein
An dieser Stelle ist es gut einmal kurz darüber zu reden, was Rust so besonders macht und was genau unsafe Rust ist.
Rust ist eine Programmiersprache welche sich zu C, C++ oder anderen Low Level sprachen einreiht. Es wird am Ende direkt in Maschinen Code kompiliert und braucht keine Runtime wie beispielsweise Java. Das tolle an Rust ist dabei, dass es zur kompilier Zeit dafür sorgen kann, dass es keine Speicherleaks oder Race conditions gibt. Gerade der zweite Punkt, ist dabei für parallele Programmierung sehr angenehm.
7. JULIAN - unsafe Rust
So profitiert also unser Multithreaded Webserver voll von den Features von Rust. Beim non blocking mussten wir aber wie bereits erwähnt, auf syscalls zugreifen. Dies bedeutet der Code kann wie bei C zu Speicherleaks führen. Dies macht die Entwicklung natürlich fehleranfälliger. Außerdem, dadurch dass unser Programm einen syscall aufruft der nicht auf jedem Betriebssystem verfügbar ist, läuft unser non blocking Server nur auf BSD System en wie beispielsweise FreeBSD oder macOS. Es gibt natürlich andere syscalls mit ähnlichen Funktionalitäten wir haben uns hier aber auf diesen einen spezialisiert.
8. JÖRG - Live penetrator zeigen
Todo
9. JULIAN - Welcher ist jetzt schneller und warum
Zusammenfassend haben wir jetzt drei verschiedene Webserver Implementierung welche wir mit dem Pennetrator gegeneinander antreten lassen. Als Beispiel haben wir ein Directory welches mehrere html Dateien unterschiedlicher Länge, so wie ein Bild gewählt. Wir lassen nun alle drei Server gegeneinander antreten und schauen welches der schnellste ist. 
Grafik hier welcher schneller ist
Wie man der Grafik entnehmen kann… todo
10. JÖRG/JULIAN - Was kann man noch alles verändern
Zum Schluss möchten wir noch mal darauf eingehen was wir dann in Zukunft beim Server noch alles verbessern könnten. Das wäre beispielsweise natürlich den neuen blocking Server auch für andere Betriebssysteme zu implementieren. Außerdem könnten wir noch httpsunterstützen und den Stats Endpunkt auch für den neuen blocking Server implementieren.
11. JÖRG/JULIAN - Was hat besonders spass gemacht, wo lagen Probleme
Wir möchten nun noch mal kurz darauf eingehen was uns denn bei dem Projekt besonders Spaß gemacht hat und womit wir unsere Probleme hatten.
Der Punkt den wir auf jeden Fall erwähnen müssen ist das rast eine wunderschöne Sprache ist welche unglaublich viel Spaß macht. Man weiß der Kot den man schreibt und der kompliziert wird funktioniert so wie man möchte.
Nicht so viel Spaß macht an sich Frust wenn man etwas das Vertrauen in den geschriebenen Kot verliert und sich nicht mehr so auf den Compiler verlassen kann. Todo Jörg
12.





