1. JÖRG - Projekt Vorstellen, Idee, warum,
Wolltet ihr nicht auch schonmal einen webserver schreiben, doch am Ende wahrt ihr euch nicht sicher, ob das was ihr geschireben habt auch wirklich so stimmt. So ging es uns immer mit C Code. Der Compiler sagt zwar alles passt, aber ob hier jetzt wirklich keine Speicherfehler sind oder Race Conditions auftreten war nie ganz klar. Wir haben uns nun dazu entschieden ein Webserver in Rust zu implementieren, welche uns mit Ihren Features hierbei unterstützen sollte. Doch dazu später mehr. todo
2. JULIAN - Perfomanter Server
Der Server besitzt einen variablen Threadpool, wessen Größe vom User festgelegt werden kann. Dabei nimmt ein thread neue requests an und teilt diese einem Worker des Pools zu. So werden nacheinander Request abgearbeitet. Bei dem Grundgerüst haben wir uns an dem im Rust Buch vorgestellten tcp server orientiert. Um diesen haben wir dann ein HTTP request und Response Model gebaut, um so HTTP Nachrichten zu verarbeiten und Antworten zu schicken.
3. JÖRG - Penetrator bauen um Massstab zu haben, wie 
Als unser Server funktionierte, wollten testen wie schnell er den nun arbeitet. Dazu haben wir den "Penetrator" geschrieben. Eine Binary welche es uns ermöglicht eine bestimmte Anzahl an requests an eine bestimmte URL zu schicken und die Zeit, die sie brauchen bis eine Antwort zurück kommt, zu messen. Diesen werden wir auch später noch kurz vorführen. todo
4. JULIAN - Andere Server, single threaded
Nachdem testen des webservers durch den Penetrator wollten wir alternativen haben, um einen Vergleich anstellen zu können. Also haben wir einen weiteren Webserver entwickelt, welcher einen thread pro request aufmacht. Dieser ist zwar einfacher, geht bei zuvielen Requests jedoch in die Knie. Doch dazu später mehr. todo
5. JULIAN - Andere Server, non blocking
Als weiteren Vergleich haben wir noch einen Single Threaded Web Server implementiert. Natürlich nicht mit nur einem Thread der alle requests blockierend ab arbeitet, sondern das ganze non blocking. Dabei haben wir uns überlegt, dass wir einen Server haben, welcher request an nimmt und diese anschließend in einer Warteschlange speichert bis der socket im request Daten zurück liefert. Währenddessen kann der Server anderen requests nachgehen. Die Abarbeitung geschieht auch nicht blockierend. Wenn alle Daten gelesen wurden liefert er den gewünschten Inhalt zurück. Dies macht er erneut non blocking.
Das besondere daran war, dass wir nicht auf die Funktionalität von Rust vertrauen konnten, da wir um die Daten nicht blockierend abzuarbeiten diese in eine Kernelqueue speichern mussten. Dafür mussten wir Syscalls aufrufen. Das wiederum geht nur mit unsafe rust.
6. JULIAN - Rust allgemein
An dieser Stelle ist es gut einmal kurz darüber zu reden, was Rust so besonders macht und was denn genau unsafe Rust ist.
Rust ist eine Programmiersprache welche sich zu C, C++ oder anderen Low Level sprachen einreiht. Es wird am Ende direkt in Maschinen Code kompiliert und braucht keine Runtime wie beispielsweise Java. Das tolle an Rust ist dabei, dass es zur kompilier Zeit dafür sorgen kann, dass es keine Speicherleaks oder Race conditions gibt. Gerade der zweite Punkt, ist dabei für parallele Programmierung sehr angenehm.
7. JULIAN - unsafe Rust
So profitiert also unser Multithreaded Webserver voll von den Features von Rust. Beim non blocking mussten wir aber wie bereits erwähnt, auf syscalls zugreifen. Dies bedeutet der Code kann wie bei C zu Speicherleaks führen. Dies macht die Entwicklung natürlich fehleranfälliger. Außerdem, dadurch dass unser Programm einen syscall aufruft der nicht auf jedem Betriebssystem verfügbar ist, läuft unser non blocking Server nur auf BSD Systemen wie beispielsweise FreeBSD oder macOS. Es gibt natürlich andere syscalls mit ähnlichen Funktionalitäten, wir haben uns hier aber auf für diesen entschieden.
8. JÖRG - Live penetrator zeigen
todo hier video
9. JULIAN - Welcher ist jetzt schneller und warum
Zusammenfassend haben wir jetzt drei verschiedene Webserver Implementierung welche wir mit dem Pennetrator gegeneinander antreten lassen. Als Beispiel haben wir ein Directory welches mehrere html Dateien unterschiedlicher Länge, so wie ein Bild gewählt. Wir lassen nun alle drei Server gegeneinander antreten und schauen welches der schnellste ist.
Grafik hier welcher schneller ist
Wie man der Grafik entnehmen kann… todo
10. Die Funktionalität des penetrators hat uns sehr gut gefallen. Aussagen darüber Treffen zu können wie viele requests geschickt wurden, welche erfolgreich waren und wie schnell diese wahren wollten wir auch in unserem Server implementiert haben. wir hatten uns vorgestellt: Es wäre doch cool wenn wir einen Endpunkt im Server haben, welcher uns dann zurück liefert wie viele requests wurden seid Start des Servers abgearbeitet, wie schnell waren diese und waren diese erfolgreich. Also war der nächste Schritt dies zu implementieren. Für unseren multithreaded server haben wir nun diese Stats implementiert und konnten nun eine schöne Übersicht über den laufenden Server bekommen.
Wie das funktioniert zeigen wir euch auch noch kurz.
10. JÖRG/JULIAN - Was kann man noch alles verändern
Zum Schluss möchten wir noch mal darauf eingehen was wir dann in Zukunft beim Server noch alles verbessern würde. Gerne würden wir beispielsweise noch https unterstützen.
11. JÖRG/JULIAN - Was hat besonders spass gemacht, wo lagen Probleme
Wir möchten nun noch mal kurz darauf eingehen was uns denn bei dem Projekt besonders Spaß gemacht hat und womit wir unsere Probleme hatten.
Der Punkt den wir auf jeden Fall erwähnen müssen ist das Rust eine wunderschöne Sprache ist welche unglaublich viel Spaß macht. Man weiß der Code den man schreibt und der kompiliert wird, funktioniert so wie er soll.
 Todo Jörg
12.





